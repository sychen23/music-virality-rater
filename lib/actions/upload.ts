"use server";

import { db } from "@/lib/db";
import { tracks, profiles, uploads } from "@/lib/db/schema";
import { auth } from "@/lib/auth";
import { headers } from "next/headers";
import { and, eq, sql } from "drizzle-orm";
import { randomBytes } from "crypto";

/** Matches filenames generated by /api/upload: <timestamp>-<random>.<ext> */
const AUDIO_FILENAME_PATTERN = /^\d+-[a-z0-9]+\.(mp3|wav|m4a)$/;

export async function createTrack(data: {
  title: string;
  audioFilename: string;
  duration: number;
  genreTags: string[];
  snippetStart: number;
  snippetEnd: number;
}) {
  const session = await auth.api.getSession({ headers: await headers() });
  if (!session) throw new Error("Unauthorized");

  const userId = session.user.id;

  // --- Validate audioFilename ---

  // 1. Regex check: filename must match the format produced by /api/upload
  if (!AUDIO_FILENAME_PATTERN.test(data.audioFilename)) {
    throw new Error("Invalid audio filename format");
  }

  // 2. Ownership check: verify the file was uploaded by this user and hasn't
  //    already been consumed by another track.
  const uploadRecord = await db.query.uploads.findFirst({
    where: and(
      eq(uploads.filename, data.audioFilename),
      eq(uploads.userId, userId),
      eq(uploads.consumed, false),
    ),
  });

  if (!uploadRecord) {
    throw new Error(
      "Audio file not found. Please upload the file before creating a track.",
    );
  }

  // Ensure profile exists
  await db
    .insert(profiles)
    .values({
      id: userId,
      handle: session.user.name?.toLowerCase().replace(/\s+/g, "") || userId.slice(0, 8),
      credits: 20,
    })
    .onConflictDoNothing({ target: profiles.id });

  const shareToken = randomBytes(8).toString("hex");

  const [track] = await db
    .insert(tracks)
    .values({
      userId,
      title: data.title,
      audioFilename: data.audioFilename,
      duration: data.duration,
      genreTags: data.genreTags,
      snippetStart: data.snippetStart,
      snippetEnd: data.snippetEnd,
      shareToken,
      status: "draft",
    })
    .returning();

  // Mark upload as consumed so it can't be reused for another track
  await db
    .update(uploads)
    .set({ consumed: true })
    .where(eq(uploads.id, uploadRecord.id));

  // Increment tracks_uploaded
  await db
    .update(profiles)
    .set({ tracksUploaded: sql`${profiles.tracksUploaded} + 1` })
    .where(eq(profiles.id, userId));

  return track;
}
