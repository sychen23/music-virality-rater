"use server";

import { db } from "@/lib/db";
import { tracks, profiles, uploads } from "@/lib/db/schema";
import { auth } from "@/lib/auth";
import { headers } from "next/headers";
import { and, eq, sql } from "drizzle-orm";
import { randomBytes } from "crypto";
import { ensureProfile } from "@/lib/queries/profiles";

/** Matches filenames generated by /api/upload: <timestamp>-<random>.<ext> */
const AUDIO_FILENAME_PATTERN = /^\d+-[a-z0-9]+\.(mp3|wav|m4a)$/;

export async function createTrack(data: {
  title: string;
  audioFilename: string;
  duration: number;
  genreTags: string[];
  snippetStart: number;
  snippetEnd: number;
}) {
  const session = await auth.api.getSession({ headers: await headers() });
  if (!session) throw new Error("Unauthorized");

  const userId = session.user.id;

  // --- Validate inputs ---

  // 1. Regex check: filename must match the format produced by /api/upload
  if (!AUDIO_FILENAME_PATTERN.test(data.audioFilename)) {
    throw new Error("Invalid audio filename format");
  }

  // 2. Validate duration is a positive finite number
  if (!Number.isFinite(data.duration) || data.duration <= 0) {
    throw new Error("Invalid duration");
  }

  // 3. Validate snippet bounds are within the track and form a valid range
  const { snippetStart, snippetEnd, duration } = data;
  if (
    !Number.isFinite(snippetStart) ||
    !Number.isFinite(snippetEnd) ||
    snippetStart < 0 ||
    snippetEnd > duration ||
    snippetEnd <= snippetStart
  ) {
    throw new Error(
      "Invalid snippet bounds. Start must be >= 0, end must be <= duration, and end must be > start."
    );
  }

  const snippetDuration = snippetEnd - snippetStart;
  if (snippetDuration < 15 || snippetDuration > 30) {
    throw new Error("Snippet must be between 15 and 30 seconds long.");
  }

  // Ensure profile exists (outside transaction since it uses onConflictDoNothing
  // and has no ordering dependency with the transactional block below)
  await ensureProfile(userId, session.user.name);

  const shareToken = randomBytes(8).toString("hex");

  // Wrap ownership check, track insert, consumed flag, and counter update in a
  // transaction so concurrent calls with the same filename can't both succeed.
  const track = await db.transaction(async (tx) => {
    // 2. Atomically claim the upload: UPDATE ... WHERE consumed = false ensures
    //    only one concurrent caller can succeed (the other matches 0 rows).
    const [claimed] = await tx
      .update(uploads)
      .set({ consumed: true })
      .where(
        and(
          eq(uploads.filename, data.audioFilename),
          eq(uploads.userId, userId),
          eq(uploads.consumed, false),
        )
      )
      .returning({ id: uploads.id });

    if (!claimed) {
      throw new Error(
        "Audio file not found. Please upload the file before creating a track.",
      );
    }

    const [newTrack] = await tx
      .insert(tracks)
      .values({
        userId,
        title: data.title,
        audioFilename: data.audioFilename,
        duration: data.duration,
        genreTags: data.genreTags,
        snippetStart: data.snippetStart,
        snippetEnd: data.snippetEnd,
        shareToken,
        status: "draft",
      })
      .returning();

    // Increment tracks_uploaded
    await tx
      .update(profiles)
      .set({ tracksUploaded: sql`${profiles.tracksUploaded} + 1` })
      .where(eq(profiles.id, userId));

    return newTrack;
  });

  return track;
}
